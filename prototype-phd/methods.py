# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_methods.ipynb.

# %% auto 0
__all__ = ['T_type', 'Z', 'sector_strategies', 'allowed_sectors', 'n_players', 'n_strategies', 'sector_weights', 'models',
           'result1', 'result2', 'result3', 'result4', 'result5', 'result6', 'expected', 'expected1', 'expected2',
           'expected3', 'expected4', 'expected5', 'expected6', 'profiles_filtered', 'result1_sum', 'result2_sum',
           'result3_sum', 'payoffs', 'β', 'result', 'result_sums', 'S', 'matrix_inds', 'n_models', 'M',
           'fermi_learning', 'fixation_rate', 'fixation_rate_stable', 'ModelTypeEGT', 'build_transition_matrix',
           'find_ergodic_distribution', 'calculate_stationary_distribution', 'gth_solve', 'calculate_sd_helper',
           'markov_chain', 'sample_profile', 'create_recurrent_states', 'valid_transition', 'compute_profile_dist',
           'compute_success', 'vals', 'infer_n_models', 'compute_success_analytical', 'payoffs_encanacao_2016']

# %% ../nbs/01_methods.ipynb 1
from .utils import *
from .model_utils import *
from .types import *

import collections
import functools
import math
import typing
from typing import Optional, List, Generator, Union, Callable
from warnings import warn

import fastcore.test
from nbdev.showdoc import *
import numpy as np
import nptyping
from scipy.linalg import schur, eigvals
from scipy.sparse import csr_matrix, csc_matrix

# %% ../nbs/01_methods.ipynb 10
def fermi_learning(fitnessA: nptyping.NDArray,  # fitness of strategy A
                   fitnessB: nptyping.NDArray,  # fitness of strategy B
                   β: nptyping.NDArray,  # learning rate
                   ) -> nptyping.NDArray:
    """Compute the likelihood that a player with strategy A adopts strategy B using the fermi function."""
    return (1 + np.exp(-β*(fitnessB - fitnessA)))**(-1)


# %% ../nbs/01_methods.ipynb 19
T_type = list[nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]]


def fixation_rate(Tplus: T_type,  # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of gaining one mutant
                  # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of losing one mutant
                  Tneg: T_type,
                  ) -> nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]:  # Fixation rates for the given strategy in each model
    """Calculate the likelihood that a mutant invades the population."""
    Z = len(Tplus) + 1
    ρ = (np.sum([np.prod([Tneg[j-1]/Tplus[j-1]
                         for j in range(1, i+1)],
                         axis=0,
                         keepdims=False)
                 for i in range(1, Z)],
                axis=0,
                keepdims=False)
         + 1)**-1
    # The fixation rate may be very close to 0. Innacuracies with floats
    # may mean that we run into issues later on. We assume the fixation rate
    # never drops below 1e-10.
    ρ = np.maximum(ρ, 1e-10)
    return ρ


# %% ../nbs/01_methods.ipynb 40
@multi
def fixation_rate_stable(ΠA: list,  # Average payoffs for the strategy A they consider adopting for each number of mutants following A
                         ΠB: list,  # Average payoffs for the strategy B that the player currently follows for each number of mutants following A
                         β: Array1D,  # learning rate
                         method="cheap", # method to dispatch on
                         ):
       return method

@method(fixation_rate_stable)
def fixation_rate_stable(ΠA: list,  # Average payoffs for the strategy A they consider adopting for each number of mutants following A
                         ΠB: list,  # Average payoffs for the strategy B that the player currently follows for each number of mutants following A
                         β: Array1D,  # learning rate
                         method=None, # method to dispatch on
                         ):
    """Calculate the likelihood that a mutant B invades population A
    using a numerically stable method."""
    fastcore.test.test_eq(len(ΠA), len(ΠB))
    Z = len(ΠA) + 1
    ρ = (np.sum([np.exp(np.clip(np.sum([-β*(ΠB[j-1] - ΠA[j-1])
                                        for j in range(1, i+1)],
                                       axis=0,
                                       keepdims=False),
                                -500,
                                500))  # avoid underflow/overflow warnings
                 for i in range(1, Z)],
                axis=0,
                keepdims=False)
         + 1)**-1
    # The fixation rate may be very close to 0. Innacuracies with floats
    # may mean that we run into issues later on. We assume the fixation rate
    # never drops below 1e-10.
#     ρ = np.maximum(ρ, 1e-15)
    return ρ

@method(fixation_rate_stable, "cheap")
def fixation_rate_stable(ΠA: list,  # Average payoffs for the strategy A they consider adopting for each number of mutants following A
                         ΠB: list,  # Average payoffs for the strategy B that the player currently follows for each number of mutants following A
                         β: Array1D,  # learning rate
                         method=None, # method to dispatch on
                         ):
    """Calculate the likelihood that a mutant B invades population A
    using a numerically stable method."""
    fastcore.test.test_eq(len(ΠA), len(ΠB))
    Z = len(ΠA) + 1
    # avoid underflow/overflow warnings
    ρ = (np.sum(np.exp(np.clip(np.cumsum([-β*(ΠB[j-1] - ΠA[j-1])
                                          for j in range(1, Z)],
                                         axis=0),
                               -500,
                               500)),  
                axis=0,
                keepdims=False)
         + 1)**-1
    # The fixation rate may be very close to 0. Innacuracies with floats
    # may mean that we run into issues later on. We assume the fixation rate
    # never drops below 1e-10.
#     ρ = np.maximum(ρ, 1e-15)
    return ρ

@method(fixation_rate_stable, "cheap2")
def fixation_rate_stable(ΠA: list,  # Average payoffs for the strategy A they consider adopting for each number of mutants following A
                         ΠB: list,  # Average payoffs for the strategy B that the player currently follows for each number of mutants following A
                         β: Array1D,  # learning rate
                         method=None, # method to dispatch on
                         ):
    """Calculate the likelihood that a mutant B invades population A
    using a numerically stable method."""
    fastcore.test.test_eq(len(ΠA), len(ΠB))
    Z = len(ΠA) + 1
    # avoid underflow/overflow warnings
    ρ = (np.sum(2**(np.clip(np.cumsum([-β*(ΠB[j-1] - ΠA[j-1])
                                          for j in range(1, Z)],
                                         axis=0),
                               -500,
                               500)),  
                axis=0,
                keepdims=False)
         + 1)**-1
    # The fixation rate may be very close to 0. Innacuracies with floats
    # may mean that we run into issues later on. We assume the fixation rate
    # never drops below 1e-10.
#     ρ = np.maximum(ρ, 1e-15)
    return ρ


# %% ../nbs/01_methods.ipynb 59
class ModelTypeEGT():
    """This is the schema for an Evolutionary Game Theory model.

    Note: This schema is not enforced and is here purely for documentation
    purposes."""

    def __init__(self,
                 Z: int,  # the size of the population
                 strategy_set: list[str],  # the set of strategies in the model
                 β: Array1D,  # the learning rate
                 payoffs: Array3D,  # the payoffs of the game
                 transition_matrix: Array3D = None,  # the model's transition matrix
                 ergodic: Array2D = None,  # ergodic distribution of the model's markov chain
                 ):
        pass


# %% ../nbs/01_methods.ipynb 61
@multi
def build_transition_matrix(models: dict  # A dictionary that contains the parameters in `ModelTypeEGT`
                            ):
    """Build a transition matrix between all monomorphic states using the
    fermi social learning rule."""
    return models.get('dispatch-type')


@method(build_transition_matrix)
def build_transition_matrix(models: dict  # A dictionary that contains the parameters in `ModelTypeEGT`
                            ):
    """Build a transition matrix between all monomorphic states
    using the fermi social learning rule for each model.    
    """

    Z, S, β = [models[k] for k in ['Z', 'strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros((n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                M[:, row_ind, row_ind] += 1
                # We calibrate these entries later so rows add up to 1
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(Z-k-1)/(Z-1) + πAB*k/(Z-1)
                  for k in range(1, Z)]
            ΠB = [πBA*(Z-k)/(Z-1) + πBB*(k-1)/(Z-1)
                  for k in range(1, Z)]
            # We use a numerically stable method to find the fixation rate, ρ.
            # ρ is the probability that mutant B successfully invades A
            ρ = fixation_rate_stable(ΠA, ΠB, β)
            M[:, row_ind, col_ind] = ρ / max(1, len(S)-1)
            M[:, row_ind, row_ind] -= ρ / max(1, len(S)-1)
    return {**models, "transition_matrix": M}


# %% ../nbs/01_methods.ipynb 62
@method(build_transition_matrix, 'unstable')
def build_transition_matrix(models: dict  # A dictionary that contains the parameters in `ModelTypeEGT`
                            ):
    """Build a transition matrix using a numerically unstable method."""

    Z, S, β = [models[k] for k in ['Z', 'strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros((n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                M[:, row_ind, row_ind] += 1
                # We calibrate these entries later so rows add up to 1
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(Z-k-1)/(Z-1) + πAB*k/(Z-1)
                  for k in range(1, Z)]
            ΠB = [πBA*(Z-k)/(Z-1) + πBB*(k-1)/(Z-1)
                  for k in range(1, Z)]
            Tneg = [fermi_learning(ΠB[k-1], ΠA[k-1], β)
                    for k in range(1, Z)]
            Tplus = [fermi_learning(ΠA[k-1], ΠB[k-1], β)
                     for k in range(1, Z)]
            ρ = fixation_rate(Tplus, Tneg)
            M[:, row_ind, col_ind] = ρ / max(1, len(S)-1)
            M[:, row_ind, row_ind] -= ρ / max(1, len(S)-1)
    return {**models, "transition_matrix": M}


# %% ../nbs/01_methods.ipynb 83
def find_ergodic_distribution(models: dict  # A dictionary that contains the parameters in `ModelTypeEGT`
                              ):
    """Find the ergodic distribution of a markov chain with the
    given transition matrix."""
    M = models["transition_matrix"]
    # find unit eigenvector of markov chain
    Λ, V = np.linalg.eig(M.transpose(0, 2, 1))
    V = np.real_if_close(V)
    x = np.isclose(Λ, 1)
    # if multiple unit eigenvalues then choose the first
    y = np.zeros_like(x, dtype=bool)
    idx = np.arange(len(x)), x.argmax(axis=1)
    y[idx] = x[idx]
    ergodic = np.array(V.transpose(0, 2, 1)[y], dtype=float)
    # ensure ergodic frequencies are positive and sum to 1
    ergodic = np.abs(ergodic) / np.sum(np.abs(ergodic), axis=1)[:, None]
    return {**models, 'ergodic': ergodic}


# %% ../nbs/01_methods.ipynb 85
@multi
def calculate_stationary_distribution(transition_matrix: Union[np.ndarray, csr_matrix, csc_matrix],
                                      method=None):
    """A multimethod for calculating the stationary distribution of different
    types of matrices."""
    return method

@method(calculate_stationary_distribution)
def calculate_stationary_distribution(transition_matrix: Union[np.ndarray, csr_matrix, csc_matrix], # A single 2D transition matrix or a 3D array containing a stack of transition matrices
                                      method=None # The method to use to find the statonary distribution, the default approach relies on using `numpy.linalg.eig` which is not recommended for non-hermitian matrices. Use "shcur" if matrix is non-hermitian.
                                      ) -> np.ndarray:
    """
    Calculates stationary distribution from a transition matrix of Markov chain.

    The use of this function is not recommended if the matrix is non-Hermitian. Please use
    calculate_stationary_distribution_non_hermitian instead in this case.

    The stationary distribution is the normalized eigenvector associated with the eigenvalue 1

    Parameters
    ----------
    transition_matrix : Union[numpy.ndarray, scipy.sparse.csr_matrix, scipy.sparse.csc_matrix]
        A 2 dimensional transition matrix

    Returns
    -------
    numpy.ndarray
        A 1-dimensional vector containing the stationary distribution

    See Also
    --------
    egttools.utils.calculate_stationary_distribution_non_hermitian

    """
    if (type(transition_matrix) == csr_matrix) or (type(transition_matrix) == csc_matrix):
        tmp = transition_matrix.toarray()
    else:
        tmp = transition_matrix
        
    if np.ndim(transition_matrix)==2:
        tmp = transition_matrix[None, ...]
    
    # Check if there is any transition with value 1 - this would mean that the game is degenerate
    if np.isclose(tmp, 1., atol=1e-11).any():
        warn(
            "Some of the entries in the transition matrix are close to 1 (with a tolerance of 1e-11). "
            "This could result in more than one eigenvalue of magnitute 1 "
            "(the Markov Chain is degenerate), so please be careful when analysing the results.", RuntimeWarning)
        
    # `numpy.linalg.eig` returns the right-handed eigenvectors so we need to tranpose our transition matrices first.
    tmp = tmp.transpose(0, 2, 1)

    # calculate stationary distributions using eigenvalues and eigenvectors
    eigenvalues, eigenvectors = np.linalg.eig(tmp)
    
    # look for the first element closest to 1 in the list of eigenvalues
    index_stationary = (np.arange(len(eigenvalues)),
                        np.argmin(np.abs(eigenvalues - 1.0), axis=-1))
    mask_stationary = np.zeros_like(eigenvalues, dtype=bool)
    mask_stationary[index_stationary] = True
    sd = np.abs(eigenvectors.transpose(0, 2, 1)[mask_stationary].real)
    return sd / np.sum(sd, axis=-1)[:, None]  # normalize


# %% ../nbs/01_methods.ipynb 86
@method(calculate_stationary_distribution, "schur")
def calculate_stationary_distribution(transition_matrix: Union[np.ndarray, csr_matrix, csc_matrix], # A single 2D transition matrix or a 3D array containing a stack of transition matrices
                                      method=None # The method to use to find the statonary distribution, the default approach relies on using `numpy.linalg.eig` which is not recommended for non-hermitian matrices. Use "shcur" if matrix is non-hermitian.
                                      ) -> np.ndarray:
    """
    Calculates stationary distribution from a transition matrix of Markov chain.

    The stationary distribution is the normalized eigenvector associated with the eigenvalue 1

    Parameters
    ----------
    transition_matrix : Union[numpy.ndarray, scipy.sparse.csr_matrix, scipy.sparse.csc_matrix]
        A 2 dimensional transition matrix

    Returns
    -------
    numpy.ndarray
        A 1-dimensional vector containing the stationary distribution

    See Also
    --------
    egttools.utils.calculate_stationary_distribution_non_hermitian

    """
    if (type(transition_matrix) == csr_matrix) or (type(transition_matrix) == csc_matrix):
        tmp = transition_matrix.toarray()
    else:
        tmp = transition_matrix
        
    if np.ndim(transition_matrix)==2:
        tmp = transition_matrix[None, ...]
    
    # Check if there is any transition with value 1 - this would mean that the game is degenerate
    if np.isclose(tmp, 1., atol=1e-11).any():
        warn(
            "Some of the entries in the transition matrix are close to 1 (with a tolerance of 1e-11). "
            "This could result in more than one eigenvalue of magnitute 1 "
            "(the Markov Chain is degenerate), so please be careful when analysing the results.", RuntimeWarning)

    # calculate stationary distributions using eigenvalues and eigenvectors
    schur_results = [schur(m) for m in tmp]
    eigenvectors = np.array([r[1] for r in schur_results]).real
    eigenvalues = np.array([eigvals(r[0]) for r in schur_results]).real
    # look for the first element closest to 1 in the list of eigenvalues
    index_stationary = (np.arange(len(eigenvalues)),
                        np.argmin(np.abs(eigenvalues - 1.0), axis=-1))
    mask_stationary = np.zeros_like(eigenvalues, dtype=bool)
    mask_stationary[index_stationary] = True
    sd = np.abs(eigenvectors[mask_stationary].real)
    return sd / np.sum(sd, axis=-1)[:, None]  # normalize


# %% ../nbs/01_methods.ipynb 87
def gth_solve(A, overwrite=False):
    r"""
    This routine computes the stationary distribution of an irreducible
    Markov transition matrix (stochastic matrix) or transition rate
    matrix (generator matrix) `A`.
    More generally, given a Metzler matrix (square matrix whose
    off-diagonal entries are all nonnegative) `A`, this routine solves
    for a nonzero solution `x` to `x (A - D) = 0`, where `D` is the
    diagonal matrix for which the rows of `A - D` sum to zero (i.e.,
    :math:`D_{ii} = \sum_j A_{ij}` for all :math:`i`). One (and only
    one, up to normalization) nonzero solution exists corresponding to
    each reccurent class of `A`, and in particular, if `A` is
    irreducible, there is a unique solution; when there are more than
    one solution, the routine returns the solution that contains in its
    support the first index `i` such that no path connects `i` to any
    index larger than `i`. The solution is normalized so that its 1-norm
    equals one. This routine implements the Grassmann-Taksar-Heyman
    (GTH) algorithm [1]_, a numerically stable variant of Gaussian
    elimination, where only the off-diagonal entries of `A` are used as
    the input data. For a nice exposition of the algorithm, see Stewart
    [2]_, Chapter 10.
    Parameters
    ----------
    A : array_like(float, ndim=2)
        Stochastic matrix or generator matrix. Must be of shape n x n.
    Returns
    -------
    x : numpy.ndarray(float, ndim=1)
        Stationary distribution of `A`.
    overwrite : bool, optional(default=False)
        Whether to overwrite `A`.
    References
    ----------
    .. [1] W. K. Grassmann, M. I. Taksar and D. P. Heyman, "Regenerative
       Analysis and Steady State Distributions for Markov Chains,"
       Operations Research (1985), 1107-1116.
    .. [2] W. J. Stewart, Probability, Markov Chains, Queues, and
       Simulation, Princeton University Press, 2009.
    """
    A1 = np.array(A, dtype=float, copy=not overwrite, order='C')
    # `order='C'` is for use with Numba <= 0.18.2
    # See issue github.com/numba/numba/issues/1103

    if len(A1.shape) != 2 or A1.shape[0] != A1.shape[1]:
        raise ValueError('matrix must be square')

    n = A1.shape[0]
    x = np.zeros(n)

    # === Reduction === #
    for k in range(n-1):
        scale = np.sum(A1[k, k+1:n])
        if scale <= 0:
            # There is one (and only one) recurrent class contained in
            # {0, ..., k};
            # compute the solution associated with that recurrent class.
            n = k+1
            break
        A1[k+1:n, k] /= scale

        A1[k+1:n, k+1:n] += np.dot(A1[k+1:n, k:k+1], A1[k:k+1, k+1:n])

    # === Backward substitution === #
    x[n-1] = 1
    for k in range(n-2, -1, -1):
        x[k] = np.dot(x[k+1:n], A1[k+1:n, k])

    # === Normalization === #
    x /= np.sum(x)

    return x

# %% ../nbs/01_methods.ipynb 88
@method(calculate_stationary_distribution, "quantecon")
def calculate_stationary_distribution(transition_matrix: Union[np.ndarray, csr_matrix, csc_matrix], # A single 2D transition matrix or a 3D array containing a stack of transition matrices
                                      method=None # The method to use to find the statonary distribution, the default approach relies on using `numpy.linalg.eig` which is not recommended for non-hermitian matrices. Use "shcur" if matrix is non-hermitian.
                                      ) -> np.ndarray:
    """
    Calculates stationary distribution from a transition matrix of Markov chain.

    The stationary distribution is the normalized eigenvector associated with the eigenvalue 1

    Parameters
    ----------
    transition_matrix : Union[numpy.ndarray, scipy.sparse.csr_matrix, scipy.sparse.csc_matrix]
        A 2 dimensional transition matrix

    Returns
    -------
    numpy.ndarray
        A 1-dimensional vector containing the stationary distribution

    See Also
    --------
    egttools.utils.calculate_stationary_distribution_non_hermitian

    """
    if (type(transition_matrix) == csr_matrix) or (type(transition_matrix) == csc_matrix):
        tmp = transition_matrix.toarray()
    else:
        tmp = transition_matrix
        
    if np.ndim(transition_matrix)==2:
        tmp = transition_matrix[None, ...]
    
    # Check if there is any transition with value 1 - this would mean that the game is degenerate
    if np.isclose(tmp, 1., atol=1e-11).any():
        warn(
            "Some of the entries in the transition matrix are close to 1 (with a tolerance of 1e-11). "
            "This could result in more than one eigenvalue of magnitute 1 "
            "(the Markov Chain is degenerate), so please be careful when analysing the results.", RuntimeWarning)
    return np.array([gth_solve(p) for p in tmp])


# %% ../nbs/01_methods.ipynb 89
def calculate_sd_helper(models):
    P =  models['transition_matrix']
    sd = calculate_stationary_distribution(P, method=models.get('sd-method'))
    return {**models, "ergodic": sd }

# %% ../nbs/01_methods.ipynb 112
def markov_chain(models: dict  # A dictionary that contains the parameters in `ModelTypeEGT`
                 ):
    """Find the ergodic distribution of the evolutionary
    game given by each model in models."""
    return thread_macro(models,
                        build_transition_matrix,
                        find_ergodic_distribution)


# %% ../nbs/01_methods.ipynb 125
@multi
def sample_profile(models):
    return models.get('sample_profile_key')


@method(sample_profile)
def sample_profile(models):
    """We sample players from their allowed sectors as per the sector weights."""
    sector_strategies = models['sector_strategies']
    allowed_sectors = models['allowed_sectors']
    profile = models['profile']
    chosen_player = models['chosen_player']
    chosen_strategy = int(models['chosen_strategy'])
    current_strategy = int(models['current_strategy'])
    mutant_strategy = int(models['mutant_strategy'])
    affected_sector = models['affected_sector']
    n_mutants = models['n_mutants']
    Z = models['Z']
    sector_weights = models.get('sector_weights', {})
    assert n_mutants >= 1
    assert n_mutants <= Z[affected_sector] - 1
    assert current_strategy != mutant_strategy
    assert chosen_strategy in [current_strategy, mutant_strategy]
    assert affected_sector in sector_strategies.keys()
    assert chosen_player in allowed_sectors.keys()

    profile_tuple = list(map(int, profile.split("-")))
    assert chosen_strategy in profile_tuple

    # TODO: does it make sense for chosen_player_likelihood to take into account
    # any possible position our chosen_player could have been in, no matter
    # which strategies each player actually plays in the profile?
    above = sector_weights.get(chosen_player, {}).get(affected_sector, 1)
    below = 0
    for player, sectors in allowed_sectors.items():
        if affected_sector in sectors:
            below += sector_weights.get(player, {}).get(affected_sector, 1)
    if below == 0:
        raise ValueError("""affected_sector is never allowed in the game, 
                         double check allowed_sectors""")
    # print("chosen_player_likelihood: ", above / below)
    chosen_player_likelihood = above / below

    likelihood = chosen_player_likelihood

    n_sampled_from_affected_sector = 1
    n_mutants_sampled = 1 if chosen_strategy == mutant_strategy else 0
    for i, strategy in enumerate(profile_tuple[::-1]):
        valid_strategy = False
        for sector in allowed_sectors[f"P{i+1}"]:
            if strategy in map(int, sector_strategies[sector]):
                valid_strategy = True
        if not valid_strategy:
            raise ValueError(f"""Profile, {profile}, implies a player plays a
                             strategy from a sector they do not belong to.""")
        if f"P{i+1}" == chosen_player:
            continue
        if strategy in map(int, sector_strategies[affected_sector]):
            if strategy == current_strategy:
                likelihood *= ((Z[affected_sector]
                                - (n_sampled_from_affected_sector
                                   - n_mutants_sampled)
                                - n_mutants)
                               / (Z[affected_sector]
                                  - n_sampled_from_affected_sector))
                # print("current-lk: ",
                #       (Z[affected_sector]
                #        - (n_sampled_from_affected_sector - n_mutants_sampled)
                #        - n_mutants),
                #       "/",
                #       (Z[affected_sector] - n_sampled_from_affected_sector))
                n_sampled_from_affected_sector += 1
            elif strategy == mutant_strategy:
                likelihood *= ((n_mutants
                                - n_mutants_sampled)
                               / (Z[affected_sector]
                                  - n_sampled_from_affected_sector))
                # print("mutant-lk: ",
                #       (n_mutants - n_mutants_sampled),
                #       "/",
                #       (Z[affected_sector] - n_sampled_from_affected_sector))
                n_mutants_sampled += 1
                n_sampled_from_affected_sector += 1
            else:
                raise ValueError("""At least one profile implies the copresence
                                 of 3 strategies for one sector. This default
                                 profile likelihood method is not meant to be
                                 used for such situations. Make sure you use
                                 profile filters to prevent passing such
                                 strategy profiles to this sampling rule.""")
        relevant_sector = [sector
                           for sector in sector_strategies.keys()
                           if strategy in map(int, sector_strategies[sector])]
        if len(relevant_sector) > 1:
            raise ValueError("Each sector must have unique strategy codes")
        elif len(relevant_sector) == 0:
            raise ValueError("Strategy does not belong to any sector")
        else:
            relevant_sector = relevant_sector[0]
        above = sector_weights.get("P{i+1}", {}).get(relevant_sector, 1)
        below = sum(sector_weights.get("P{i+1}", {}).get(sector, 1)
                    for sector in allowed_sectors[f"P{i+1}"])
        likelihood *= above / below
        # print("relevant_sector_likelihood: ", above / below)
    return likelihood


# %% ../nbs/01_methods.ipynb 130
Z = {"S3": 10, "S2": 10, "S1": 10}
sector_strategies = {"S3": [5, 6],
                     "S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "profile": "5-3-1",
          "chosen_player": "P1",
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }
result1 = sample_profile(models)
result2 = sample_profile({**models, "n_mutants": 8})
result3 = sample_profile({**models, "n_mutants": 9})
result4 = sample_profile({**models,
                          "affected_sector": "S2",
                          "chosen_player": "P2",
                          "current_strategy": 3,
                          "mutant_strategy": 4,
                          "chosen_strategy": 3})
result5 = sample_profile({**models,
                          "profile": "5-3-2",
                          "current_strategy": 1,
                          "mutant_strategy": 2,
                          "chosen_strategy": 2})
result6 = sample_profile({**models,
                          "profile": "6-3-1",
                          "affected_sector": "S3",
                          "chosen_player": "P3",
                          "current_strategy": 5,
                          "mutant_strategy": 6,
                          "chosen_strategy": 6})
expected = (1  # "P1" is from "S1": it must be our chosen_player with the chosen_strategy
            * 1  # "P2" can only be from "S2", but all players form that sector play 3
            * 1  # "P3" can only be from "S3", but all players form that sector play 5
            )
fastcore.test.test_eq(result1, expected)
fastcore.test.test_eq(result2, expected)
fastcore.test.test_eq(result3, expected)
fastcore.test.test_eq(result4, expected)
fastcore.test.test_eq(result5, expected)
fastcore.test.test_eq(result6, expected)


# %% ../nbs/01_methods.ipynb 133
Z = {"S3": 10, "S2": 10, "S1": 10}
sector_strategies = {"S3": [5, 6],
                     "S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "profile": "5-3-1",
          "chosen_player": "P1",
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }

with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models, "n_mutants": 1000})
with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models, "chosen_strategy": 2})
with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models, "profile": "5-3-2"})
with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models,
                    "mutant_strategy": 5,
                    "current_strategy": 6})
with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models,
                    "mutant_strategy": 1,
                    "current_strategy": 1})
with fastcore.test.ExceptionExpected(ex=ValueError):
    sample_profile({**models,
                    "sector_strategies": {**sector_strategies,
                                          "S3": [3, 4]}})
with fastcore.test.ExceptionExpected(ex=ValueError):
    sample_profile({**models, "profile": "10-6-1"})
with fastcore.test.ExceptionExpected(ex=AssertionError):
    sample_profile({**models,
                    "sector_strategies": {"S3": [5, 6],
                                          "S2": [3, 4]}})
with fastcore.test.ExceptionExpected(ex=ValueError):
    sample_profile({**models,
                    "allowed_sectors": {"P1": ["S2"],
                                        "P2": ["S2"],
                                        "P3": ["S3"]}})
with fastcore.test.ExceptionExpected(ex=ValueError):
    sample_profile({**models,
                    "sector_strategies": {"S1": [1, 2, 3]},
                    "allowed_sectors": {"P1": ["S1"],
                                        "P2": ["S1"],
                                        "P3": ["S1"]},
                    "profile": "3-2-1"})
with fastcore.test.ExceptionExpected(ex=ValueError):
    sample_profile({**models,
                    "profile": "3-2-1"})
with fastcore.test.ExceptionExpected(ex=KeyError):
    sample_profile({**models,
                    "sector_strategies": {"S1": [1, 2, 3]},
                    "profile": "3-2-1"})


# %% ../nbs/01_methods.ipynb 136
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "profile": "3-2-1",
          "chosen_player": "P1",
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }


result1 = sample_profile(models)
result2 = sample_profile({**models, "n_mutants": 8})
result3 = sample_profile({**models,
                          "chosen_strategy": 2,
                          "chosen_player": "P2"})
result4 = sample_profile({**models,
                          "current_strategy": 2,
                          "mutant_strategy": 1,
                          "chosen_strategy": 2,
                          "chosen_player": "P2"})
result5 = sample_profile({**models,
                          "profile": "3-2-2",
                          "current_strategy": 1,
                          "mutant_strategy": 2,
                          "chosen_strategy": 2})
result6 = sample_profile({**models,
                          "profile": "3-1-2",
                          "current_strategy": 1,
                          "mutant_strategy": 2,
                          "chosen_strategy": 2})
expected1 = (  # "P1" is our chosen_player. The likelihood of choosing our
    # chosen player given the affected_sector is just the likelihood of
    # choosing that player instead of any other player. chosen_player
    # is the first player we sample, and they must be present, so only
    # the liklelihood of each player sampling from the affected sector
    # matters. In this case, 2 of the players have the same same of
    # sampling from "S1", and the other has a 0% change. So, the
    # likelihood of them being "P1" is 50%.
    0.5
    # "P2", like our chosen player, "P1" is from "S1". We have 2
    # mutants in the affected sector, and "P2" is using the mutant
    # strategy. The probability of this happening is
    * 2 / (10 - 1)
    * 1  # "P3" can only be from "S3" and all "S3" members play 3
)
expected2 = (0.5 * 8 / 9 * 1)
expected3 = (8 / 9 * 0.5 * 1)
expected4 = (2 / 9 * 0.5 * 1)
expected5 = (0.5 * 1 / 9 * 1)
expected6 = (0.5 * 8 / 9 * 1)
fastcore.test.test_eq(result1, expected1)
fastcore.test.test_eq(result2, expected2)
fastcore.test.test_eq(result3, expected3)
fastcore.test.test_eq(result4, expected4)
fastcore.test.test_eq(result5, expected5)
fastcore.test.test_eq(result6, expected6)


# %% ../nbs/01_methods.ipynb 139
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S1", "S2"],
                   "P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "profile": "2-2-1",
          "chosen_player": "P1",
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }


result1 = sample_profile(models)
result2 = sample_profile({**models, "n_mutants": 8})
result3 = sample_profile({**models,
                          "chosen_strategy": 2,
                          "chosen_player": "P2"})
result4 = sample_profile({**models,
                          "current_strategy": 2,
                          "mutant_strategy": 1,
                          "chosen_strategy": 2,
                          "chosen_player": "P2"})
result5 = sample_profile({**models,
                          "profile": "3-2-2",
                          "current_strategy": 1,
                          "mutant_strategy": 2,
                          "chosen_strategy": 2})
result6 = sample_profile({**models,
                          "profile": "3-1-2",
                          "current_strategy": 1,
                          "mutant_strategy": 2,
                          "chosen_strategy": 2})
expected1 = (  # "P1" is our chosen_player. We could have chosen any player
    # since all players can sample from the affected sector. Moreover,
    # they all do so with equal likelihood, so the likelihood of
    # choosing to follow "P-1" is 1/3
    1 / 3
    # "P2", like our chosen player, "P1" is from "S1". We have 2
    # mutants in the affected sector, and "P2" is using the mutant
    # strategy. We need the likelihood that an "S1" member was sampled
    # instead of an "S2" member as well as the likelihood the "S1"
    # member was a mutant
    * 2 / (10 - 1) * 0.5
    # "P3" is also from "S1" and plays the mutant strategy too.
    # We sample without replacement, so the probability is
    * 1 / (10 - 2) * 0.5
)
expected2 = (1 / 3
             * 8 / 9 / 2
             * 7 / 8 / 2)
expected3 = (8 / 9 / 2
             * 1 / 3
             * 1 / 8 / 2)
expected4 = (2 / 9 / 2
             * 1 / 3
             * 7 / 8 / 2)
expected5 = (1 / 3
             * 1 / 9 / 2
             * 1 / 2)
expected6 = (1 / 3
             * 8 / 9 / 2
             * 1 / 2)
fastcore.test.test_eq(result1, expected1)
fastcore.test.test_eq(result2, expected2)
fastcore.test.test_eq(result3, expected3)
fastcore.test.test_eq(result4, expected4)
fastcore.test.test_eq(result5, expected5)
fastcore.test.test_eq(result6, expected6)


# %% ../nbs/01_methods.ipynb 143
def create_recurrent_states(models):
    """Create all recurrent-states for the set of models."""
    sector_strategies = models['sector_strategies']
    n_states = np.prod([len(S) for S in sector_strategies.values()])
    sorted_keys = sorted(sector_strategies, reverse=True)
    strategy_axes = [sector_strategies[k] for k in sorted_keys]
    grid = build_grid_from_axes(strategy_axes)
    states = ["-".join(map(str, row)) for row in grid]
    fastcore.test.test_eq(len(states), n_states)
    return states


# %% ../nbs/01_methods.ipynb 148
def valid_transition(ind1: str,  # The index of the current state, expressed in the form "{strategy_code}-{strategy_code}-{strategy_code}"
                     ind2: str,  # The index of the next state, expressed in the same form as `ind1`
                     ) -> bool:  # True if the transition is valid, false otherwise
    """Check if the transition from ind1->ind2 is valid
    i.e. that only one population undergoes a change in strategy."""
    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    valid = sum(differ) == 1
    return valid


# %% ../nbs/01_methods.ipynb 150
fastcore.test.test_eq(valid_transition("1-1-1", "2-1-1"), True)
fastcore.test.test_eq(valid_transition("1-1-1", "2-1-2"), False)
fastcore.test.test_eq(valid_transition("1-1-1", "0-0-0"), False)
fastcore.test.test_eq(valid_transition("1-1-1", "22-1-3"), False)
# Even though possible, self transitions are marked as false since we never compute them directly
fastcore.test.test_eq(valid_transition("1-1-1", "1-1-1"), False)


# %% ../nbs/01_methods.ipynb 152
@multi
def compute_profile_dist(models):
    """Compute the probability distribution of the relevant profiles."""
    return models.get('profile_dist_rule')


@method(compute_profile_dist)
def compute_profile_dist(models):
    """Compute the probability distribution of the relevant profiles - default."""
    chosen_strategy = models['chosen_strategy']
    profiles = models['profiles_filtered']
    profile_distribution = {}
    for profile in profiles:
        profile_tuple = list(map(int, profile.split("-")))
        possible_players = [f"P{i+1}"
                            for i, strategy in enumerate(profile_tuple[::-1])
                            if strategy == chosen_strategy]
        profile_distribution[profile] = {}
        for chosen_player in possible_players:
            likelihood = sample_profile({**models,
                                         "profile": profile,
                                         "chosen_player": chosen_player})
            profile_distribution[profile][chosen_player] = likelihood
    return profile_distribution


# %% ../nbs/01_methods.ipynb 153
@method(compute_profile_dist, 'multi-player-symmetric')
def compute_profile_dist(models):
    """Compute the probability distribution of the relevant profiles - we have
    one profile per combination of players and only compute the likelihood for
    the relevant player type."""
    chosen_strategy = models['chosen_strategy']
    profiles = models['profiles_filtered']
    profile_distribution = {}
    counter = collections.Counter()
    visited = collections.defaultdict()
    for profile in profiles:
        profile_tuple = list(map(int, profile.split("-")))
        unique, counts = np.unique(profile_tuple, return_counts=True)
        counter_key = "-".join([f"{u}:{c}" for u, c in zip(unique, counts)])
        counter[counter_key] += 1
        visited[counter_key] = False
    for profile in profiles:
        profile_tuple = list(map(int, profile.split("-")))
        unique, counts = np.unique(profile_tuple, return_counts=True)
        counter_key = "-".join([f"{u}:{c}" for u, c in zip(unique, counts)])
        if visited[counter_key]:
            # If we have seen a profile with the same strategy counts, skip it
            continue
        else:
            visited[counter_key] = True
            possible_players = [f"P{i+1}"
                                for i, strategy in enumerate(profile_tuple[::-1])
                                if strategy == chosen_strategy]
            profile_distribution[profile] = {}
            if len(possible_players) > 0:
                # Player order does not matter
                chosen_player = possible_players[0]
                likelihood = sample_profile({**models,
                                             "profile": profile,
                                             "chosen_player": chosen_player})
                # We must multiply the above likelihood by the number of ways
                # this combination of players can be permuted.
                likelihood *= counter[counter_key] * len(possible_players)
                profile_distribution[profile][chosen_player] = likelihood
    return profile_distribution


# %% ../nbs/01_methods.ipynb 157
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "n_players": n_players,
          "n_strategies": n_strategies,
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      (assoc, "transition_indices", ["3-1", "3-2"]),
                      apply_profile_filters)
profiles_filtered = ['1-1', '1-2', '1-3',
                     '2-1', '2-2', '2-3',
                     '3-1', '3-2', '3-3']
fastcore.test.test_eq(models["profiles_filtered"], profiles_filtered)

result1 = compute_profile_dist(models)
expected1 = {'1-1': {"P1": 7 / 9 / 2 / 2, "P2": 7 / 9 / 2 / 2},
             '1-2': {"P2": 2 / 9 / 2 / 2},
             '1-3': {"P2": 1 / 2 / 2},
             '2-1': {"P1": 2 / 9 / 2 / 2},
             '2-2': {},
             '2-3': {},
             '3-1': {"P1": 1 / 2 / 2},
             '3-2': {},
             '3-3': {}}
for profile in profiles_filtered:
    fastcore.test.test_eq(result1[profile], expected1[profile])


result1_sum = 0
for likelihoods_by_player in result1.values():
    for likelihood in likelihoods_by_player.values():
        result1_sum += likelihood
fastcore.test.test_eq(result1_sum, 1)


result2 = compute_profile_dist({**models, "chosen_strategy": 2})
expected2 = {'1-1': {},
             '1-2': {"P1": 8 / 9 / 2 / 2},
             '1-3': {},
             '2-1': {"P2": 8 / 9 / 2 / 2},
             '2-2': {"P1": 1 / 9 / 2 / 2, "P2": 1 / 9 / 2 / 2},
             '2-3': {"P2": 1 / 2 / 2},
             '3-1': {},
             '3-2': {"P1": 1 / 2 / 2},
             '3-3': {}}
for profile in profiles_filtered:
    fastcore.test.test_eq(result2[profile], expected2[profile])

result2_sum = 0
for likelihoods_by_player in result1.values():
    for likelihood in likelihoods_by_player.values():
        result2_sum += likelihood
fastcore.test.test_eq(result2_sum, 1)

result3 = compute_profile_dist({**models, "n_mutants": 5})
expected3 = {'1-1': {"P1": 4 / 9 / 2 / 2, "P2": 4 / 9 / 2 / 2},
             '1-2': {"P2": 5 / 9 / 2 / 2},
             '1-3': {"P2": 1 / 2 / 2},
             '2-1': {"P1": 5 / 9 / 2 / 2},
             '2-2': {},
             '2-3': {},
             '3-1': {"P1": 1 / 2 / 2},
             '3-2': {},
             '3-3': {}}
for profile in profiles_filtered:
    fastcore.test.test_eq(result3[profile], expected3[profile])

result3_sum = 0
for likelihoods_by_player in result1.values():
    for likelihood in likelihoods_by_player.values():
        result3_sum += likelihood
fastcore.test.test_eq(result2_sum, 1)


# %% ../nbs/01_methods.ipynb 160
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P5": ["S1", "S2"],
                   "P4": ["S1", "S2"],
                   "P3": ["S1", "S2"],
                   "P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "n_players": n_players,
          "n_strategies": n_strategies,
          "chosen_strategy": 1,
          "current_strategy": 1,
          "mutant_strategy": 2,
          "affected_sector": "S1",
          "n_mutants": 2,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      (assoc, "transition_indices", ["3-1", "3-2"]),
                      apply_profile_filters)
profiles_filtered = ['1-1-1-1-1',
                     '1-1-1-1-2',
                     '1-1-1-1-3',
                     '1-1-1-2-2',
                     '1-1-1-2-3',
                     '1-1-1-3-3',
                     '1-1-2-2-2',
                     '1-1-2-2-3',
                     '1-1-2-3-3',
                     '1-1-3-3-3',
                     '1-2-2-2-2',
                     '1-2-2-2-3',
                     '1-2-2-3-3',
                     '1-2-3-3-3',
                     '1-3-3-3-3',
                     '2-2-2-2-2',
                     '2-2-2-2-3',
                     '2-2-2-3-3',
                     '2-2-3-3-3',
                     '2-3-3-3-3',
                     '3-3-3-3-3', ]
# fastcore.test.test_eq(models["profiles_filtered"], profiles_filtered)

result1 = compute_profile_dist({**models,
                                "profile_dist_rule": "multi-player-symmetric"})
result2 = compute_profile_dist(models)

# The expected results take the probability of attaining a given profile when
# sampling all other players from the availabe sectors and player types (top few
# lines), divided by the chance your agent was sampled to be in of the player
# positions (in this case this is always 1/5), multiplied by the number of
# different positions the player could be in for the given profile, and then
# multiplied by the number of permutations of the given (read these numbers
# from left to right on the last line).
expected1 = {'1-1-1-1-1': {'P1': (math.comb(7, 4) / math.comb(9, 4) / 2**4
                                  / 5 * 5 * 1)},
             '1-1-1-1-2': {'P2': (math.comb(7, 3) / math.comb(9, 3) / 2**3
                                  * math.comb(2, 1) / math.comb(6, 1) / 2
                                  / 5 * 4 * 5)},
             '1-1-1-1-3': {'P2': (math.comb(7, 3) / math.comb(9, 3) / 2**3
                                  * (1 / 2)
                                  / 5 * 4 * 5)},
             '1-1-1-2-2': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * math.comb(2, 2) / math.comb(7, 2) / 2**2
                                  / 5 * 3 * 10)},
             '1-1-1-2-3': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * math.comb(2, 1) / math.comb(7, 1) / 2
                                  * (1 / 2)
                                  / 5 * 3 * 20)},
             '1-1-1-3-3': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * (1 / 2)**2
                                  / 5 * 3 * 10)},
             '1-1-2-2-2': {'P4': 0.0},  # Too many mutants so impossible
             '1-1-2-2-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * math.comb(2, 2) / math.comb(8, 2) / 2**2
                                  * (1 / 2)
                                  / 5 * 2 * 30)},
             '1-1-2-3-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * math.comb(2, 1) / math.comb(8, 1) / 2
                                  * (1 / 2)**2
                                  / 5 * 2 * 30)},
             '1-1-3-3-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * (1 / 2)**3
                                  / 5 * 2 * 10)},
             '1-2-2-2-2': {'P5': 0.0},  # Too many mutants so impossible
             '1-2-2-2-3': {'P5': 0.0},  # Too many mutants so impossible
             '1-2-2-3-3': {'P5': (math.comb(2, 2) / math.comb(9, 2) / 2**2
                                  * (1 / 2)**2
                                  / 5 * 1 * 30)},
             '1-2-3-3-3': {'P5': (math.comb(2, 1) / math.comb(9, 1) / 2
                                  * (1 / 2)**3
                                  / 5 * 1 * 20)},
             '1-3-3-3-3': {'P5': ((1 / 2)**4
                                  / 5 * 1 * 5)},
             '2-2-2-2-2': {},  # Chosen strategy not present so impossible
             '2-2-2-2-3': {},  # Chosen strategy not present so impossible
             '2-2-2-3-3': {},  # Chosen strategy not present so impossible
             '2-2-3-3-3': {},  # Chosen strategy not present so impossible
             '2-3-3-3-3': {},  # Chosen strategy not present so impossible
             '3-3-3-3-3': {}}  # Chosen strategy not present so impossible
for profile in profiles_filtered:
    for player in expected1[profile].keys():
        fastcore.test.test_close(result1[profile][player],
                                 expected1[profile][player])


result1_sum = 0
for likelihoods_by_player in result1.values():
    for likelihood in likelihoods_by_player.values():
        result1_sum += likelihood
fastcore.test.test_close(result1_sum, 1)

# The expected results take the probability of attaining a given profile when
# sampling all other players from the availabe sectors and player types (top few
# lines), divided by the chance your agent was sampled to be in of the player
# positions (in this case this is always 1/5).
expected2 = {'1-1-1-1-1': {'P1': (math.comb(7, 4) / math.comb(9, 4) / 2**4
                                  / 5)},
             '1-1-1-1-2': {'P2': (math.comb(7, 3) / math.comb(9, 3) / 2**3
                                  * math.comb(2, 1) / math.comb(6, 1) / 2
                                  / 5)},
             '1-1-1-1-3': {'P2': (math.comb(7, 3) / math.comb(9, 3) / 2**3
                                  * (1 / 2)
                                  / 5)},
             '1-1-1-2-2': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * math.comb(2, 2) / math.comb(7, 2) / 2**2
                                  / 5)},
             '1-1-1-2-3': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * math.comb(2, 1) / math.comb(7, 1) / 2
                                  * (1 / 2)
                                  / 5)},
             '1-1-1-3-3': {'P3': (math.comb(7, 2) / math.comb(9, 2) / 2**2
                                  * (1 / 2)**2
                                  / 5)},
             '1-1-2-2-2': {'P4': 0.0},  # Too many mutants so impossible
             '1-1-2-2-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * math.comb(2, 2) / math.comb(8, 2) / 2**2
                                  * (1 / 2)
                                  / 5)},
             '1-1-2-3-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * math.comb(2, 1) / math.comb(8, 1) / 2
                                  * (1 / 2)**2
                                  / 5)},
             '1-1-3-3-3': {'P4': (math.comb(7, 1) / math.comb(9, 1) / 2
                                  * (1 / 2)**3
                                  / 5)},
             '1-2-2-2-2': {'P5': 0.0},  # Too many mutants so impossible
             '1-2-2-2-3': {'P5': 0.0},  # Too many mutants so impossible
             '1-2-2-3-3': {'P5': (math.comb(2, 2) / math.comb(9, 2) / 2**2
                                  * (1 / 2)**2
                                  / 5)},
             '1-2-3-3-3': {'P5': (math.comb(2, 1) / math.comb(9, 1) / 2
                                  * (1 / 2)**3
                                  / 5)},
             '1-3-3-3-3': {'P5': ((1 / 2)**4
                                  / 5)},
             '2-2-2-2-2': {},  # Chosen strategy not present so impossible
             '2-2-2-2-3': {},  # Chosen strategy not present so impossible
             '2-2-2-3-3': {},  # Chosen strategy not present so impossible
             '2-2-3-3-3': {},  # Chosen strategy not present so impossible
             '2-3-3-3-3': {},  # Chosen strategy not present so impossible
             '3-3-3-3-3': {}}  # Chosen strategy not present so impossible
for profile in profiles_filtered:
    for player in expected1[profile].keys():
        fastcore.test.test_close(result2[profile][player],
                                 expected2[profile][player])


# %% ../nbs/01_methods.ipynb 162
@multi
def compute_success(models):
    """Compute the success of the two strategies under consideration."""
    return models.get('compute_success_rule', "cheap")


@method(compute_success)
def compute_success(models):
    """Compute the success of the two strategies under consideration for each
    number of k mutants implied by the transition."""
    models = apply_profile_filters(models)
    ind1, ind2 = models['transition_indices']
    sector_strategies = models['sector_strategies']
    Z = models['Z']
    payoffs = models['payoffs']

    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
    current_strategy = ind1_tuple[np.argmax(differ)]
    mutant_strategy = ind2_tuple[np.argmax(differ)]

    ΠA = []
    ΠB = []
    for n_mutants in range(1, Z[affected_sector]):
        dist1 = compute_profile_dist({**models,
                                      'chosen_strategy': current_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        dist2 = compute_profile_dist({**models,
                                      'chosen_strategy': mutant_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        success_A = 0
        for profile, player_map in dist1.items():
            for player, likelihood in player_map.items():
                success_A += payoffs[profile][player] * likelihood
        ΠA.append(success_A)
        success_B = 0
        for profile, player_map in dist2.items():
            for player, likelihood in player_map.items():
                success_B += payoffs[profile][player] * likelihood
        ΠB.append(success_B)
    return ΠA, ΠB

@method(compute_success, "cheap")
def compute_success(models):
    """Compute the success of the two strategies under consideration for each
    number of k mutants implied by the transition."""
    models = apply_profile_filters(models)
    ind1, ind2 = models['transition_indices']
    sector_strategies = models['sector_strategies']
    Z = models['Z']
    payoffs = models['payoffs']

    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
    current_strategy = ind1_tuple[np.argmax(differ)]
    mutant_strategy = ind2_tuple[np.argmax(differ)]

    ΠA = []
    ΠB = []
    for n_mutants in range(1, Z[affected_sector]):
        dist1 = compute_profile_dist({**models,
                                      'chosen_strategy': current_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        dist2 = compute_profile_dist({**models,
                                      'chosen_strategy': mutant_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        payoffsA = []
        likelihoodsA = []
        for profile, player_map in dist1.items():
            for player, likelihood in player_map.items():
                payoffsA.append(payoffs[profile][player])
                likelihoodsA.append(likelihood)
        ΠA.append(np.dot(np.array(payoffsA).T, likelihoodsA))
        payoffsB = []
        likelihoodsB = []
        for profile, player_map in dist2.items():
            for player, likelihood in player_map.items():
                payoffsB.append(payoffs[profile][player]) 
                likelihoodsB.append(likelihood)
        ΠB.append(np.dot(np.array(payoffsB).T, likelihoodsB))
    return ΠA, ΠB


@method(compute_success, "functional")
def compute_success(models):
    """Compute the success of the two strategies under consideration for each
    number of k mutants implied by the transition."""
    models = apply_profile_filters(models)
    ind1, ind2 = models['transition_indices']
    sector_strategies = models['sector_strategies']
    Z = models['Z']
    payoffs_function = models['payoffs_function']

    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
    current_strategy = ind1_tuple[np.argmax(differ)]
    mutant_strategy = ind2_tuple[np.argmax(differ)]

    ΠA = []
    ΠB = []
    for n_mutants in range(1, Z[affected_sector]):
        dist1 = compute_profile_dist({**models,
                                      'chosen_strategy': current_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        dist2 = compute_profile_dist({**models,
                                      'chosen_strategy': mutant_strategy,
                                      'current_strategy': current_strategy,
                                      'mutant_strategy': mutant_strategy,
                                      'affected_sector': affected_sector,
                                      'n_mutants': n_mutants})
        # Record the strategy counts in the population implied by the number of
        # mutants so that our payoff function can make use of this information
        strategy_counts = {str(strategy): Z[sector]
                           for strategy in ind1_tuple
                           for sector in sector_strategies.keys()
                           if strategy in sector_strategies[sector]}
        strategy_counts = {**strategy_counts,
                           str(current_strategy): Z[affected_sector] - n_mutants,
                           str(mutant_strategy): n_mutants}
        population_state = models.get("population_state", {})
        population_state = {**population_state,
                            "strategy_counts": strategy_counts}
        # Compute the payoffs for each strategy in each possible profile
        # and the likelihood of that profile occuring.
        payoffsA = []
        likelihoodsA = []
        for profile, player_map in dist1.items():
            for player, likelihood in player_map.items():
                payoffsA.append(payoffs_function({**models,
                                                  "population_state": population_state,
                                                  "profile": profile,
                                                  "player": player}))
                likelihoodsA.append(likelihood)
        ΠA.append(np.dot(np.array(payoffsA).T, likelihoodsA))
        payoffsB = []
        likelihoodsB = []
        for profile, player_map in dist2.items():
            for player, likelihood in player_map.items():
                payoffsB.append(payoffs_function({**models,
                                                  "population_state": population_state,
                                                  "profile": profile,
                                                  "player": player}))
                likelihoodsB.append(likelihood)
        ΠB.append(np.dot(np.array(payoffsB).T, likelihoodsB))
    return ΠA, ΠB


# %% ../nbs/01_methods.ipynb 167
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "n_players": n_players,
          "n_strategies": n_strategies,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      (assoc, "transition_indices", ["3-1", "3-2"]),
                      apply_profile_filters)
profiles_filtered = ['1-1', '1-2', '1-3',
                     '2-1', '2-2', '2-3',
                     '3-1', '3-2', '3-3']
fastcore.test.test_eq(models["profiles_filtered"], profiles_filtered)

payoffs = {}
for profile in profiles_filtered:
    payoffs[profile] = {}
    for player in allowed_sectors.keys():
        payoffs[profile][player] = 1
models = {**models, "payoffs": payoffs}

result1 = compute_success(models)
expected1 = [[1 for _ in range(9)],
             [1 for _ in range(9)], ]
for result, expected in zip(result1[0], expected1[0]):
    fastcore.test.test_close(result, expected)
for result, expected in zip(result1[1], expected1[1]):
    fastcore.test.test_close(result, expected)


# %% ../nbs/01_methods.ipynb 170
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "n_players": n_players,
          "n_strategies": n_strategies,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      (assoc, "transition_indices", ["3-1", "3-2"]),
                      apply_profile_filters)
profiles_filtered = ['1-1', '1-2', '1-3',
                     '2-1', '2-2', '2-3',
                     '3-1', '3-2', '3-3']
fastcore.test.test_eq(models["profiles_filtered"], profiles_filtered)

payoffs = {
    '1-1': {'P1': 2, 'P2': 2},
    '1-2': {'P1': 4, 'P2': 0},
    '1-3': {'P1': 3, 'P2': 3},
    '1-4': {'P1': 6, 'P2': 0},
    '2-1': {'P1': 0, 'P2': 4},
    '2-2': {'P1': 1, 'P2': 1},
    '2-3': {'P1': 0, 'P2': 6},
    '2-4': {'P1': 2, 'P2': 1},
    '3-1': {'P1': 3, 'P2': 3},
    '3-2': {'P1': 6, 'P2': 0},
    '3-3': {'P1': 4, 'P2': 4},
    '3-4': {'P1': 8, 'P2': 0},
    '4-1': {'P1': 0, 'P2': 6},
    '4-2': {'P1': 1, 'P2': 2},
    '4-3': {'P1': 0, 'P2': 8},
    '4-4': {'P1': 2, 'P2': 2},
}

result2 = compute_success({**models, "payoffs": payoffs})
# 50% chance of facing strategy 3 no matter if we look at player 1 or 2.
# Otherwise, we have a 0.5 * (n_mutants / z_s1) chance of facing strategy 2
# and a 0.5 * ((z_s1 - n_mutants) / z_s1) chance of facing strategy 1.
expected2 = [[((0.5
                * k / (Z["S1"] - 1)
                * payoffs['2-1']['P1'])
               + (0.5
                  * (Z["S1"] - 1 - k) / (Z["S1"] - 1)
                  * payoffs['1-1']['P1'])
               + 0.5 * payoffs['3-1']['P1'])
              for k in range(1, 10)],
             [((0.5
                * (k - 1) / (Z["S1"] - 1)
                * payoffs['2-2']['P1'])
               + (0.5
                  * (Z["S1"] - k) / (Z["S1"] - 1)
                  * payoffs['1-2']['P1'])
               + 0.5 * payoffs['3-2']['P1'])
              for k in range(1, 10)], ]
for result, expected in zip(result2[0], expected2[0]):
    fastcore.test.test_close(result, expected)
for result, expected in zip(result2[1], expected2[1]):
    fastcore.test.test_close(result, expected)


# %% ../nbs/01_methods.ipynb 173
Z = {"S2": 10, "S1": 10}
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
n_players = len(allowed_sectors.keys())
n_strategies = [len(strategies) for strategies in sector_strategies]

sector_weights = {}

models = {"Z": Z,
          "sector_strategies": sector_strategies,
          "allowed_sectors": allowed_sectors,
          "n_players": n_players,
          "n_strategies": n_strategies,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      (assoc, "transition_indices", ["3-1", "3-2"]),
                      apply_profile_filters)
profiles_filtered = ['1-1', '1-2', '1-3',
                     '2-1', '2-2', '2-3',
                     '3-1', '3-2', '3-3']
fastcore.test.test_eq(models["profiles_filtered"], profiles_filtered)

payoffs = {}
for profile in profiles_filtered:
    payoffs[profile] = {}
    for player in allowed_sectors.keys():
        payoffs[profile][player] = np.random.beta(1, 1)
models = {**models, "payoffs": payoffs}

result2 = compute_success({**models, "payoffs": payoffs})
# 50% chance of facing strategy 3 no matter if we look at player 1 or 2.
# Otherwise, we have a 0.5 * (n_mutants / z_s1) chance of facing strategy 2
# and a 0.5 * ((z_s1 - n_mutants) / z_s1) chance of facing strategy 1.
# For each of these there is a 50% of being player 1 or player 2.
expected2 = [[((0.5
                * k / (Z["S1"] - 1)
                * (payoffs['2-1']['P1']
                   + payoffs['1-2']['P2']) / 2
                )
               + (0.5
                  * (Z["S1"] - 1 - k) / (Z["S1"] - 1)
                  * (payoffs['1-1']['P1']
                     + payoffs['1-1']['P2']) / 2
                  )
               + (0.5
                  * (payoffs['3-1']['P1']
                     + payoffs['1-3']['P2']) / 2
                  )
               )
              for k in range(1, 10)],
             [((0.5
                * (k - 1) / (Z["S1"] - 1)
                * (payoffs['2-2']['P1']
                   + payoffs['2-2']['P2']) / 2
                )
               + (0.5
                  * (Z["S1"] - k) / (Z["S1"] - 1)
                  * (payoffs['1-2']['P1']
                     + payoffs['2-1']['P2']) / 2
                  )
               + (0.5
                  * (payoffs['3-2']['P1']
                     + payoffs['2-3']['P2']) / 2
                  )
               )
              for k in range(1, 10)], ]
for result, expected in zip(result2[0], expected2[0]):
    fastcore.test.test_close(result, expected)
for result, expected in zip(result2[1], expected2[1]):
    fastcore.test.test_close(result, expected)


# %% ../nbs/01_methods.ipynb 175
def vals(d: dict):
    "Return the values of a dictionary."
    return d.values()


# %% ../nbs/01_methods.ipynb 176
def infer_n_models(models):
    "Infer the number of models from the model payoffs."
    try:
        payoffs = models.get('payoffs')
        payoff_vector = thread_macro(payoffs,
                                     vals,
                                     iter,
                                     next,
                                     vals,
                                     iter,
                                     next)
        n_models = (1
                    if isinstance(payoff_vector, (float, int))
                    else len(payoff_vector))
    except:
        raise ValueError("""Unable to infer `n_models`.
                         `payoffs` is structured incorrectly""")
    return n_models


# %% ../nbs/01_methods.ipynb 181
@method(build_transition_matrix, 'multiple-populations')
def build_transition_matrix(models: dict  # A dictionary that contains the parameters in `ModelTypeEGTMultiple`
                            ):
    """Build a transition matrix between all monomorphic states
    when there are multiple populations.    
    """
    β = models['β']
    n_models = models.get('n_models',
                          infer_n_models(models))
    S = models.get('recurrent_states',
                   create_recurrent_states(models))
    M = np.zeros((n_models, len(S), len(S)))
    for row_ind in range(M.shape[-1]):
        M[:, row_ind, row_ind] += 1
    transition_inds = [(i, j)
                       for i in range(len(S))
                       for j in range(len(S))]
    for row_ind, col_ind in transition_inds:
        current_state, new_state = S[row_ind], S[col_ind]
        if current_state == new_state:
            continue
        if not valid_transition(current_state, new_state):
            continue
        ΠA, ΠB = compute_success(assoc(models,
                                       "transition_indices",
                                       [current_state, new_state]))
        # TODO: Clean up assymetric beta code below
        ind1_tuple = list(map(int, current_state.split("-")))
        ind2_tuple = list(map(int, new_state.split("-")))
        differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
        affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
        if isinstance(β, dict):
            ρ = fixation_rate_stable(ΠA, ΠB, β[affected_sector])
        else:
            ρ = fixation_rate_stable(ΠA, ΠB, β)
        n_mutations = sum(valid_transition(current_state, s_alt)
                          for s_alt in S)
        M[:, row_ind, col_ind] = ρ / n_mutations
        M[:, row_ind, row_ind] -= ρ / n_mutations
    return {**models, 'transition_matrix': M,
            'recurrent_states': S,
            'n_models': n_models}


# %% ../nbs/01_methods.ipynb 187
β = 1
Z = {"S1": 50, "S2": 50, "S3": 50}
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1]}

models = {"dispatch-type": "multiple-populations",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

models = thread_macro(models,
                      create_profiles,
                      apply_profile_filters)

payoffs = {}
for profile in models['profiles_filtered']:
    payoffs[profile] = {}
    for player in models['allowed_sectors'].keys():
        payoffs[profile][player] = np.array([np.random.beta(1, 1)
                                             for _ in range(2)])
models = {**models, "payoffs": payoffs}

result = build_transition_matrix(models)['transition_matrix']
result_sums = np.sum(result, axis=-1)
fastcore.test.test_close(result_sums, 1)


# %% ../nbs/01_methods.ipynb 191
@multi
def compute_success_analytical(models):
    return models.get('success_analytical_derivation')


@method(compute_success_analytical, '2sector2strategy2player')
def compute_success_analytical(models):
    """Compute the success of each strategy involved in a transition for
    a game with two players who can each be from one of two sectors. Each
    sector uses two strategies."""

    # 50% chance of facing fixed strategy no matter if we look at mutant or
    # current strategy
    # Otherwise, we have a 0.5 * (n_mutants / z_s1) chance of facing strategy 2
    # and a 0.5 * ((z_s1 - n_mutants) / z_s1) chance of facing strategy 1.
    # For each of theses there is a 50% of being player 1 or player 2.
    transition_indices = models['transition_indices']
    Z = models['Z']
    payoffs = models['payoffs']
    ind1, ind2 = transition_indices
    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
    current_strategy = ind1_tuple[np.argmax(differ)]
    mutant_strategy = ind2_tuple[np.argmax(differ)]
    # We only support two sectors here, so we know the other value must be the
    # fixed sector.
    fs = ind1_tuple[np.argmin(differ)]
    cs = current_strategy
    ms = mutant_strategy
    SA, SB = [], []
    z = Z[affected_sector]
    for k in range(1, z):
        successA = ((0.5
                    * k / (z - 1)
                    * (payoffs[f"{ms}-{cs}"]['P1']
                        + payoffs[f"{cs}-{ms}"]['P2']) / 2
                     )
                    + (0.5
                        * (z - 1 - k) / (z - 1)
                        * (payoffs[f"{cs}-{cs}"]['P1']
                           + payoffs[f"{cs}-{cs}"]['P2']) / 2
                       )
                    + (0.5
                        * (payoffs[f"{fs}-{cs}"]['P1']
                           + payoffs[f"{cs}-{fs}"]['P2']) / 2
                       )
                    )
        SA.append(successA)
        successB = ((0.5
                     * (k - 1) / (z - 1)
                     * (payoffs[f"{ms}-{ms}"]['P1']
                         + payoffs[f"{ms}-{ms}"]['P2']) / 2
                     )
                    + (0.5
                       * (z - k) / (z - 1)
                       * (payoffs[f"{cs}-{ms}"]['P1']
                           + payoffs[f"{ms}-{cs}"]['P2']) / 2
                       )
                    + (0.5
                       * (payoffs[f"{fs}-{ms}"]['P1']
                          + payoffs[f"{ms}-{fs}"]['P2']) / 2
                       )
                    )
        SB.append(successB)
    return SA, SB


# %% ../nbs/01_methods.ipynb 192
Z = {"S2": 10, "S1": 10}
β = 1
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P2": ["S1", "S2"],
                   "P1": ["S1", "S2"]}
sector_weights = {}

models = {"dispatch-type": "multiple-populations",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          #   "sector_weights": sector_weights,
          }

models = thread_macro(models,
                      create_profiles,
                      apply_profile_filters)

payoffs = {}
for profile in models['profiles_filtered']:
    payoffs[profile] = {}
    for player in allowed_sectors.keys():
        payoffs[profile][player] = np.array([np.random.beta(1, 1)
                                             for _ in range(2)])
models = {**models, "payoffs": payoffs}

result = thread_macro({**models, "payoffs": payoffs},
                      build_transition_matrix,
                      (get, "transition_matrix"))

# Generate expected results
S = ['3-1', '3-2', '4-1', '4-2']
matrix_inds = [(i, j)
               for i in range(len(S))
               for j in range(len(S))]
n_models = infer_n_models(models)
M = np.zeros((n_models, len(S), len(S)))
for i in range(M.shape[-1]):
    M[:, i, i] += 1
for i, j in matrix_inds:
    transition_indices = [S[i], S[j]]
    current_state, new_state = transition_indices
    if current_state == new_state:
        continue
    if not valid_transition(current_state, new_state):
        continue
    transition_indices = [current_state, new_state]
    expected_model = {"transition_indices": transition_indices,
                      "Z": Z,
                      "payoffs": payoffs,
                      "success_analytical_derivation": "2sector2strategy2player"}
    PA, PB = compute_success_analytical(expected_model)
    rho = fixation_rate_stable(PA, PB, β)
    M[:, i, j] += rho / 2
    M[:, i, i] -= rho / 2

# Test that expected and actual results are close
for row_ind in range(M.shape[2]):
    for col_ind in range(M.shape[1]):
        for model_ind in range(M.shape[0]):
            if not fastcore.test.is_close(M[model_ind, col_ind, row_ind],
                                          result[model_ind, col_ind, row_ind]):
                print("indices: ", model_ind, col_ind, row_ind)
            fastcore.test.test_close(M[model_ind, col_ind, row_ind],
                                     result[model_ind, col_ind, row_ind])


# %% ../nbs/01_methods.ipynb 195
@method(compute_success_analytical, '2sector2strategy3player')
def compute_success_analytical(models):
    """Compute the success of each strategy involved in a transition for
    a game with three players where two players are from one sector and the
    third is from another. Each sector uses two strategies."""

    # 100% chance of third player playing either their chosen strategy if they
    # are the chosen agent, or otherwise 100% chance of third player playing
    # their current strategy.
    # If chosen agent in first sector, we have a (n_mutants / z_s1) chance of
    # facing strategy 2 and a ((z_s1 - n_mutants) / z_s1) chance of facing
    # strategy 1.
    # For each of these, there is a 50% chance of being player 1 or player 2.
    # If chosen player is the third player, then they have a 100% of facing
    # against the fixed strategy played by the other two players.
    transition_indices = models['transition_indices']
    Z = models['Z']
    payoffs = models['payoffs']
    allowed_sectors = models['allowed_sectors']
    ind1, ind2 = transition_indices
    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1 != i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
    current_strategy = ind1_tuple[np.argmax(differ)]
    mutant_strategy = ind2_tuple[np.argmax(differ)]
    # We only support two sectors here, so we know the other value must be the
    # fixed sector.
    fs = ind1_tuple[np.argmin(differ)]
    cs = current_strategy
    ms = mutant_strategy
    SA, SB = [], []
    z = Z[affected_sector]
    relevant_players = [p
                        for p in allowed_sectors.keys()
                        if affected_sector in allowed_sectors[p]]
    if len(relevant_players) == 1:
        for k in range(1, z):
            SA.append(payoffs[f"{cs}-{fs}-{fs}"]['P3'])
            SB.append(payoffs[f"{ms}-{fs}-{fs}"]['P3'])
    elif len(relevant_players) == 2:
        for k in range(1, z):
            successA = ((k / (z - 1)
                        * (payoffs[f"{fs}-{ms}-{cs}"]['P1']
                            + payoffs[f"{fs}-{cs}-{ms}"]['P2']) / 2
                         )
                        + ((z - 1 - k) / (z - 1)
                            * (payoffs[f"{fs}-{cs}-{cs}"]['P1']
                               + payoffs[f"{fs}-{cs}-{cs}"]['P2']) / 2
                           )
                        )
            SA.append(successA)
            successB = (((k - 1) / (z - 1)
                        * (payoffs[f"{fs}-{ms}-{ms}"]['P1']
                            + payoffs[f"{fs}-{ms}-{ms}"]['P2']) / 2
                         )
                        + ((z - k) / (z - 1)
                        * (payoffs[f"{fs}-{cs}-{ms}"]['P1']
                            + payoffs[f"{fs}-{ms}-{cs}"]['P2']) / 2
                           )
                        )
            SB.append(successB)
    return SA, SB


# %% ../nbs/01_methods.ipynb 196
Z = {"S2": 10, "S1": 10}
β = 1
sector_strategies = {"S2": [3, 4],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"]}
sector_weights = {}

models = {"dispatch-type": "multiple-populations",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

models = thread_macro(models,
                      create_profiles,
                      apply_profile_filters)

payoffs = {}
for profile in models['profiles_filtered']:
    payoffs[profile] = {}
    for player in allowed_sectors.keys():
        payoffs[profile][player] = np.array([np.random.beta(1, 1)
                                             for _ in range(2)])
models = {**models, "payoffs": payoffs}

result = thread_macro({**models, "payoffs": payoffs},
                      build_transition_matrix,
                      (get, "transition_matrix"))

# Generate expected results
S = ['3-1', '3-2', '4-1', '4-2']
matrix_inds = [(i, j)
               for i in range(len(S))
               for j in range(len(S))]
n_models = infer_n_models(models)
M = np.zeros((n_models, len(S), len(S)))
for i in range(M.shape[-1]):
    M[:, i, i] += 1
for i, j in matrix_inds:
    transition_indices = [S[i], S[j]]
    current_state, new_state = transition_indices
    if current_state == new_state:
        continue
    if not valid_transition(current_state, new_state):
        continue
    transition_indices = [current_state, new_state]
    expected_model = {"transition_indices": transition_indices,
                      "Z": Z,
                      "payoffs": payoffs,
                      "allowed_sectors": allowed_sectors,
                      "success_analytical_derivation": "2sector2strategy3player"}
    PA, PB = compute_success_analytical(expected_model)
    rho = fixation_rate_stable(PA, PB, β)
    M[:, i, j] += rho / 2
    M[:, i, i] -= rho / 2

# Test that expected and actual results are close
for row_ind in range(M.shape[2]):
    for col_ind in range(M.shape[1]):
        for model_ind in range(M.shape[0]):
            if not fastcore.test.is_close(M[model_ind, col_ind, row_ind],
                                          result[model_ind, col_ind, row_ind]):
                print("indices: ", model_ind, col_ind, row_ind)
            fastcore.test.test_close(M[model_ind, col_ind, row_ind],
                                     result[model_ind, col_ind, row_ind])

# %% ../nbs/01_methods.ipynb 197
Z = {"S2": 10, "S1": 10}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2]}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"]}
sector_weights = {}

models = {"dispatch-type": "multiple-populations",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

models = thread_macro(models,
                      create_profiles,
                      apply_profile_filters)

payoffs = {}
for profile in models['profiles_filtered']:
    payoffs[profile] = {}
    for player in allowed_sectors.keys():
        payoffs[profile][player] = np.array([np.random.beta(1, 1)
                                             for _ in range(2)])
models = {**models, "payoffs": payoffs}

result = thread_macro({**models, "payoffs": payoffs},
                      build_transition_matrix,
                      (get, "transition_matrix"))

# Generate expected results
S = ['4-1', '4-2', '5-1', '5-2']
matrix_inds = [(i, j)
               for i in range(len(S))
               for j in range(len(S))]
n_models = infer_n_models(models)
M = np.zeros((n_models, len(S), len(S)))
for i in range(M.shape[-1]):
    M[:, i, i] += 1
for i, j in matrix_inds:
    transition_indices = [S[i], S[j]]
    current_state, new_state = transition_indices
    if current_state == new_state:
        continue
    if not valid_transition(current_state, new_state):
        continue
    transition_indices = [current_state, new_state]
    expected_model = {"transition_indices": transition_indices,
                      "Z": Z,
                      "payoffs": payoffs,
                      "allowed_sectors": allowed_sectors,
                      "success_analytical_derivation": "2sector2strategy3player"}
    PA, PB = compute_success_analytical(expected_model)
    rho = fixation_rate_stable(PA, PB, β)
    M[:, i, j] += rho / 2
    M[:, i, i] -= rho / 2

# Test that expected and actual results are close
for row_ind in range(M.shape[2]):
    for col_ind in range(M.shape[1]):
        for model_ind in range(M.shape[0]):
            if not fastcore.test.is_close(M[model_ind, col_ind, row_ind],
                                          result[model_ind, col_ind, row_ind]):
                print("indices: ", model_ind, col_ind, row_ind)
            fastcore.test.test_close(M[model_ind, col_ind, row_ind],
                                     result[model_ind, col_ind, row_ind])

# %% ../nbs/01_methods.ipynb 200
def payoffs_encanacao_2016(models):
    names = ['b_r', 'b_s', 'c_s', 'c_t', 'σ']
    b_r, b_s, c_s, c_t, σ = [models[k] for k in names]
    payoffs = {}
    n_players = 3
    n_sectors = 3
    n_strategies_per_sector = [2, 2, 2]
    n_strategies_total = 6
    # All players are from the first sector, playing that sector's first strategy
    index_min = "0-0-0"
    # All players are from the third sector, playing that sector's second strategy
    index_max = "5-5-5"
    # Note: The seperator makes it easy to represent games where n_strategies_total >= 10.

    # It is also trivial to define a vector which maps these indexes to strategy profiles
    # As sector order is fixed we could neglect to mention suscripts for each sector
    strategy_names = ["D", "C", "D", "C", "D", "C"]

    zero = np.zeros(b_r.shape[0])
    # As in the main text
    payoffs["C-C-C"] = {"P3": b_r-2*c_s,
                        "P2": σ+b_s-c_t,
                        "P1": σ+b_s}
    payoffs["C-C-D"] = {"P3": -c_s,
                        "P2": b_s-c_t,
                        "P1": zero}
    payoffs["C-D-C"] = {"P3": b_r-c_s,
                        "P2": zero,
                        "P1": b_s}
    payoffs["C-D-D"] = {"P3": zero,
                        "P2": σ,
                        "P1": σ}
    payoffs["D-C-C"] = {"P3": zero,
                        "P2": σ-c_t,
                        "P1": σ}
    payoffs["D-C-D"] = {"P3": zero,
                        "P2": -c_t,
                        "P1": zero}
    payoffs["D-D-C"] = {"P3": zero,
                        "P2": zero,
                        "P1": zero}
    payoffs["D-D-D"] = {"P3": zero,
                        "P2": σ,
                        "P1": σ}

    # The following indexes capture all strategy profiles where each player is fixed to a unique sector
    # (and player order does not matter, so we need only consider one ordering of sectors).
    payoffs["4-2-0"] = payoffs["D-D-D"]
    payoffs["4-2-1"] = payoffs["D-D-C"]
    payoffs["4-3-0"] = payoffs["D-C-D"]
    payoffs["4-3-1"] = payoffs["D-C-C"]
    payoffs["5-2-0"] = payoffs["C-D-D"]
    payoffs["5-2-1"] = payoffs["C-D-C"]
    payoffs["5-3-0"] = payoffs["C-C-D"]
    payoffs["5-3-1"] = payoffs["C-C-C"]
    return {**models, "payoffs": payoffs}


# %% ../nbs/01_methods.ipynb 201
Z = {"S3": 50, "S2": 50, "S1": 50}
β = 0.08
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1], }
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"], }
sector_weights = {}

models = {"dispatch-type": "multiple-populations",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          #   "sector_weights": sector_weights,
          'b_r': np.array([0.8]),
          'b_s': np.array([0.4]),
          'c_s': np.array([0.15]),
          'c_t': np.array([0.15]),
          'σ': np.array([0.2]),
          }

models = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      payoffs_encanacao_2016,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
models['transition_matrix']
models['ergodic'], np.sum(models['ergodic'][0, 4:])

